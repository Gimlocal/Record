#### 정수
```cpp
#include <iostream>
using namespace std;

int hp = 100;	// 초기값이 있으면 .data 영역 없으면 .bss 영역

char a;		// 1바이트 (-128 ~ 127)
short b;	// 2바이트
int c;		// 4바이트
__int64 d;	// 8바이트(long long)

unsigned char ua;	// 1바이트 (0 ~ 255)
unsigned short ub;	// 2바이트
unsigned int uc;		// 4바이트
unsigned __int64 ud;	// 8바이트(long long)
// unsigned가 붙으면 음수가 아닌 양수만 표현

int main()
{
	b = 32767;
	b += 1;
	cout << b << "\n";  // 0111~1111에서 1000~0000이 됐기 때문에 음수로 바뀜
	
	ub = 0;
	ub -= 1;
	cout << ub;   // 1000~0000에서 0111~1111이 됐기 때문에 양수로 바뀜
}
```

#### 불리안과 실수
```cpp
#include <iostream>
using namespace std;

// 불리언과 상수
bool flag = true;

// bool은 그냥 1바이트 정수
// 어셈블리에서 bool이라는 것은 없음
// 단지 1이냐 아니냐의 차이

// 실수 (부동소수점)
// 3.14 ...

float speed = -3.375f;		// 4바이트 (f를 붙여야함)
double speed2 = 1332.4123;	// 8바이트

// 3.14를 표현.
// 점 앞/뒤를 기준으로 16/16씩 끊으면?
// (0~65535) . (0~65535) 까지밖에 표현 못함

// 부동소수점 (.을 유동적으로 움직여서 표현하는 방법)
// 3.1415926535
//	1. 정규화 = 0.31415926535 * 10
//	2. 31415926535 (유효숫자) 1 (지수) 로 표현함

// float 부호(1) 지수(8) 유효숫자(23) = 32비트 = 4바이트
// double 부호(1) 지수 (11) 유효숫자(52) = 64비트 = 8바이트


// ex) -3.375라는 값을 저장
// 1. 2진수로 변환
// 1-1 0.375 = 0.5 * 0 + 0.25 * 1 + 0.125 * 1 = 0b0.011
//	3.375 = 3 + 0.375 = 0b11 + 0b0.011 = 0b11.011
// 2. 정규화 -> 0b11.011 > 0b1.1011 * 2^1
//	1(부호) 1(지수) 1011(유효숫자)
//  단 지수는 unsigned byte라고 가정하고 숫자 +127 만들어줌
// 예상 결과 : 0b 1 10000000 1011000 0000 0000 0000 0000

// 부동소수점은 항상 근사값임을 기억.
// 특히 수가 커질수록 오차범위도 커짐.
// 그래서 실수끼리의 비교도 지양해야함.


int main()
{
	cout << flag;
}
```

